var store = [{
        "title": "Spring Boot Application Context Event",
        "excerpt":"[상황]     어플리케이션을 개발하다보니 다중 Data Source의 사용이 필요하다.     먼저 Data Source를 정의하고, Data Source와 연결되는 SessionFactory, SessionTemplate, TransactionManager를 각각 정의해서 개발환경을 구축하고, 개발.page__content을 진행했다.     개발을 진행하던 와중에 Data Source를 추가가 필요해서 위 작업을 동일하게 작업을 진행하였다.     Data Source 정의만으로 위의 작업을 자동화 할 수 있다면, 보다 나은 개발환경이 구축되지 않을까?    위 상황과 같이 다중 Data Source를 사용하기 위해서는 Data Source를 사용할 수 있는 SqlSession 등을  각각 정의해서 사용해야 한다. 이러한 작업은 생각보다 번거롭고 귀찮은 작업이다. 또, 이를 위해  소모되는 시간도 신경을 안쓸 수는 없을 것이다.   이를 해결하기 위해 Data Source만을 정의함으로써 MyBatis SessionFactory, SessionTemplate,  TransactionManager를 자동으로 생성해서 Bean으로 등록해보기로 했다.(이번 포스트에서는 자동화 코드는 다루지 않는다.)   이를 위해서 어플리케이션이 시작될 때 위 작업을 자동화해야 했으며, Bean 등록에 필요한  Application Context 가져올 방법을 찾던 중 Application Context에 대한 Event Listener을 알게 되었다.   어플리케이션이 실행될 때 일어나는 이벤트는 다음과 같다.     ContextRefreshedEvent: ApplicationContext를 초기화 하거나, Refresh 할 경우 발생   ContextStartedEvent: ApplicationContext를 start()하여 LifeCycle이 시작되는 시점에 발생   ContextStoppedEvent: ApplicationContext를 stop()하여 LifeCycle이 정지되는 시점에 발생   ContextClosedEvent: ApplicationContext를 close()하여 LifeCycle이 종료되는 시점에 발생   위 이벤트를 위한 EventHandler(또는 EventListener)는 아래와 같이 구현할 수 있다.  @Component public class ApplicationCtxHandler {     @EventListener     public void handle(ContextRefreshedEvent event) {         ApplicationContext context = event.getApplicationContext();     }      @EventListener     public void handle(ContextStartedEvent event) {         ApplicationContext context = event.getApplicationContext();     }      @EventListener     public void handle(ContextStoppedEvent event) {         ApplicationContext context = event.getApplicationContext();     }      @EventListener     public void handle(ContextClosedEvent event) {         ApplicationContext context = event.getApplicationContext();     } }   ContextRefreshedEvent 이벤트의 경우 ApplicationContext가 변경되는 시점에서 호출되기 때문에, 중복하여 호출될 수 있다는 것을 반드시 유의해야 한다.   [참고]     [Spring] 스프링 시작시점에서 프로그램 동작할 수 있게 하는 방법   [Spring] ApplicationEventPublisher를 통한 스프링 이벤트 처리(ApplicationEventPublisher, Spring Event Processing)  ","categories": ["Technical"],
        "tags": ["SpringBoot"],
        "url": "https://ysjee141.github.io/blog/technical/ContextRefreshedEvent/",
        "teaser": null
      },{
        "title": "JMH(Java Microbenchmark Harness) 사용법",
        "excerpt":"개발을 진행하다가 보면, 성능문제를 해결해야 하는 경우는 매우 많다.   성능 문제를 해결하기 위해서는 우선 성능을 측정해야하며, 성능을 측정하는 방법와 도구는 셀수도 없이 많다.  대부분의 경우 개발환경 또는 운영환경에 어플리케이션이 배포가 되고, Stress Test를 진행하여 성능을 측정한다.  이러한 방법은 매우 일반적이며 어플리케이션의 성능을 개선하기 위해서는 당연히 수행해야 하는 작업이다.   이러한 성능 도구는 어플리케이션의 기능 수행 측면에서의 성능 측정이고,  일부 로직에 대한 성능을 측정하고 비교하기에는 무거운 감이 없지 않다.  개발을 하다보면, 특정 코드에 대한 간단한 비교가 필요하기도 하고, 학습을 위해 각 코드에 대한  성능을 비교해야 할 경우도 많이 있을 것이다. 이렇듯 코드에 대한 성능측정을 하기 위한 방법을 찾던 중  JMH(Java Microbenchmark Harness)란 도구를 알게 되어 사용법을 정리해 본다.   JMH를 통해 벤치마킹 테스트를 하기 위해서는 Project를 생성해야 한다. 만약, 이미 만들어진 프로젝트에  JMH을 사용하려면 Maven Dependency를 추가하면 된다.   Maven Project 생성  $ mvn archetype:generate \\     -DinteractiveMode=false \\      -DarchetypeGroupId=org.openjdk.jmh \\      -DarchetypeArtifactId=jmh-java-benchmark-archetype \\      -DgroupId=com.happl.test \\     -DartifactId=code-benchmark \\     -Dversion=1  Maven Dependency    &lt;dependency&gt;     &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;     &lt;artifactId&gt;jmh-core&lt;/artifactId&gt;     &lt;version&gt;1.19&lt;/version&gt;   &lt;/dependency&gt;   &lt;dependency&gt;     &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;     &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt;     &lt;version&gt;1.19&lt;/version&gt;   &lt;/dependency&gt;   성능 측정을 위해서는 JMH에서 지원하는 Annotation을 사용하여 코드를 작성하면 된다. 예제는 아래와 같다.  @State(Scope.Thread) @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.MILLISECONDS) public class LoopTest { \t@Setup \tpublic void init() {         // 성능 측정 전 사전에 필요한 작업\t\t \t}  \t@Benchmark \tpublic void originLoopWithGetSize() {         // 성능을 측정할 코드 작성 \t}      public static void main(String[] args) throws IOException, RunnerException {         Options opt = new OptionsBuilder()                 .include(LoopTest.class.getSimpleName())                 .warmupIterations(10)           // 사전 테스트 횟수                 .measurementIterations(10)      // 실제 측정 횟수                 .forks(1)                       //                  .build();         new Runner(opt).run();                  // 벤치마킹 시작     } }   측정이 완료되면 다음과 같은 결과가 출력된다.  # Run complete. Total time: 00:01:43  Benchmark                       Mode  Cnt  Score   Error  Units LoopTest.forEach                avgt   10  0.990 ± 0.096  ms/op LoopTest.forEachByJdk8          avgt   10  0.703 ± 0.160  ms/op LoopTest.forEachByStream        avgt   10  0.561 ± 0.057  ms/op LoopTest.originLoop             avgt   10  0.634 ± 0.117  ms/op LoopTest.originLoopWithGetSize  avgt   10  0.876 ± 0.093  ms/op  ","categories": ["Technical"],
        "tags": ["Java","Benchmark","JMH"],
        "url": "https://ysjee141.github.io/blog/technical/java-benchmark/",
        "teaser": null
      },{
        "title": "블로그를 시작하며...",
        "excerpt":"요즘 개발자들은 누구라 할 것 없이 블로그를 하는 것 같습니다.  덕분에 참고할 자료가 많아져서 개발하기가 많이 수월해졌고 저 또한  이러한 블로그들을 참고하면서 개발을 진행하고, 지식을 습득하고 있습니다.   그러나 적지 않은 시간을 개발자로서 살아오며, 다른 분들의 지식을 찾아다니기만 했지,  정작 나 스스로 무언가를 정리하거나 공유할 생각을 하지는 못했던 것 같았습니다.  남들 다하는 블로그를 이제 시작하려 하는데, 사실 무엇을 정리해야할지도 잘 모르겠습니다.   다만 나 스스로 조금 더 성장하는 과정의 일부분으로 생각하고 하나 하나 조금씩 정리하려합니다.  모든 포스팅은 제가 아는 범위에서 작성되는 것이고, 따라서 잘못된 부분이 있을 수도 있습니다.  잘못된 부분은 포스팅의 댓글로 알려주시면, 보완하여 수정토록 하겠습니다.  ","categories": ["My Story"],
        "tags": ["My Story"],
        "url": "https://ysjee141.github.io/blog/my%20story/my-story/",
        "teaser": null
      }]
